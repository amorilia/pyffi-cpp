// this grammar converts an FFI AST into a FileFormat instance
tree grammar FFIFileFormat;

options {
    language=C;
    output=AST;
    ASTLabelType=pANTLR3_BASE_TREE;
    tokenVocab=FFI;
}

/*------------------------------------------------------------------
 * PARSER RULES
 *------------------------------------------------------------------*/

@includes {
    #include "pyffi/object_models/class.hpp"
    using namespace pyffi::object_models;
}

@members {
    // convert antlr string to std::string
    std::string get_string(pANTLR3_STRING s) {
        return std::string((const char *)s->chars); 
    };
}

ffi[PClass class_]
    :   formatdefine[class_] declarations[class_]?
    ;

doc
    :   ^(DOC SHORTDOC*)
    ;

formatdefine[PClass class_]
    :   ^(FILEFORMAT doc
            {
                /*
                class_->def(
                    "extensions",
                    class_->class_("_Extensions", std::vector<std::string>()));
                */
            }
            (n=CONSTANTNAME
                {
                    /*
                    class_->get_attr("extensions")->value->get<std::vector<std::string> >().push_back(get_string($n.text));
                    */
                }
            )*
        )
    ;

declarations[PClass class_]
    :   (fielddefine[class_] | classdefine[class_] | enumdefine[class_])+
    ;

enumdefine[PClass class_]
@init {
    PClass new_class;
    PClass base_class;
}
    :   ^(ENUMDEF doc
            name=TYPENAME
            base=TYPENAME
            {
                printf("*** BASE CLASS ***\n"); // XXX debug
                printf((const char *)($base.text)->chars); // XXX debug
                printf("\n"); // XXX debug
                base_class = class_->get_class(get_string($base.text));
                printf("*** MAIN CLASS ***\n"); // XXX debug
                printf((const char *)($name.text)->chars); // XXX debug
                printf("\n"); // XXX debug
                if (base_class) {
                    new_class = class_->class_(
                        get_string($name.text),
                        base_class);
                } else {
                    new_class = class_->class_(
                        get_string($name.text));
                };
            }
            enumconstant[new_class, base_class]+
        )
    ;

enumconstant[PClass class_, PClass base_class]
    :   ^(ENUMCONSTDEF doc CONSTANTNAME expression)
        {
            printf("*** ATTRIBUTE NAME ***\n"); // XXX debug
            printf((const char *)($CONSTANTNAME.text)->chars); // XXX debug
            printf("\n"); // XXX debug
            class_->def(get_string($CONSTANTNAME.text), base_class);
        }
    ;

classdefine[PClass class_]
@init {
    PClass new_class;
    PClass base_class;
}
    :   ^(CLASSDEF doc name=TYPENAME 
            ^(BASE 
                (base=TYPENAME
                    {
                        printf("*** BASE CLASS ***\n"); // XXX debug
                        printf((const char *)($base.text)->chars); // XXX debug
                        printf("\n"); // XXX debug
                        base_class = class_->get_class(get_string($base.text));
                    }
                )?
            )
            {
                printf("*** MAIN CLASS ***\n"); // XXX debug
                printf((const char *)($name.text)->chars); // XXX debug
                printf("\n"); // XXX debug
                if (base_class) {
                    new_class = class_->class_(
                        get_string($name.text),
                        base_class);
                } else {
                    new_class = class_->class_(
                        get_string($name.text));
                };
            }
            declarations[new_class]?
        )
    ;

/* empty OP_INDEX generated by XML.g, so we handle it here */
fielddefine[PClass class_]
@init {
    PClass type_class;
}
    :   ^(FIELDDEF doc TYPENAME VARIABLENAME (OP_INDEX|fieldindices)? fieldarguments? ABSTRACT?)
        {
            printf("*** ATTRIBUTE TYPE ***\n"); // XXX debug
            printf((const char *)($TYPENAME.text)->chars); // XXX debug
            printf("\n"); // XXX debug
            type_class = class_->get_class(get_string($TYPENAME.text));
            try {
                printf("*** ATTRIBUTE NAME ***\n"); // XXX debug
                printf((const char *)($VARIABLENAME.text)->chars); // XXX debug
                printf("\n"); // XXX debug
                // XXX default value should be instance; at the moment we just
                // XXX identify it with the class, for testing
                class_->def(get_string($VARIABLENAME.text), type_class);
            } catch (const pyffi::runtime_error &) {
                printf("*** (ATTRIBUTE WAS ALREADY ADDED) ***\n"); // XXX debug
                if (type_class != class_->get_class(get_string($TYPENAME.text))) {
                    throw pyffi::runtime_error("Duplicate attributes must have the same type.");
                };
				; // nothing - the key was already added, but we allow this
			};
        }
    |   ^(IF expression fielddefines[class_]
            (^(ELIF expression fielddefines[class_]))*
            (^(ELSE fielddefines[class_]))?
        )
    ;

// for convenience in the above parser rule
fielddefines[PClass class_]
    :   fielddefine[class_]+
    ;

kwarg
    :   ^(KWARG VARIABLENAME expression)
    ;

fieldarguments
    :   ^(OP_CALL kwarg+)
    ;

fieldindices
    :   ^(OP_INDEX expression+)
    ;

expression
    :   VARIABLENAME
    |   INT
    |   FLOAT
    |   STRING
    |   ^(OP_LOGICAL_OR expression expression)
    |   ^(OP_LOGICAL_AND expression expression)
    |   ^(OP_LOGICAL_NOT expression)
    |   ^(OP_EQ expression expression)
    |   ^(OP_NEQ expression expression)
    |   ^(OP_GT expression expression)
    |   ^(OP_LT expression expression)
    |   ^(OP_GTEQ expression expression)
    |   ^(OP_LTEQ expression expression)
    |   ^(OP_BITWISE_OR expression expression)
    |   ^(OP_BITWISE_AND expression expression)
    |   ^(OP_LEFTSHIFT expression expression)
    |   ^(OP_RIGHTSHIFT expression expression)
    |   ^(OP_PLUS expression expression)
    |   ^(OP_MINUS expression expression)
    |   ^(OP_NEGATE expression)
    |   ^(OP_BITWISE_NOT expression)
    |   ^(OP_MULTIPLY expression expression)
    |   ^(OP_DIVIDE expression expression)
    |   ^(OP_MODULO expression expression)
    |   ^(OP_POWER expression expression)
    |   ^(OP_CALL expression kwarg+)
    |   ^(OP_INDEX expression expression+)
    ;
