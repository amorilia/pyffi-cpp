// this grammar converts an FFI AST into a FileFormat instance
tree grammar FFIFileFormat;

options {
    language=C;
    output=AST;
    ASTLabelType=pANTLR3_BASE_TREE;
    tokenVocab=FFI;
}

/*------------------------------------------------------------------
 * PARSER RULES
 *------------------------------------------------------------------*/

@includes {
    #include "pyffi/object_models/class.hpp"
    using namespace pyffi::object_models;
}

@members {
    // convert antlr string to std::string
    std::string get_string(pANTLR3_STRING s) {
        return std::string((const char *)s->chars); 
    };
}

ffi[PClass class_]
    :   formatdefine[class_] declarations[class_]?
    ;

doc
    :   ^(DOC SHORTDOC*)
    ;

formatdefine[PClass class_]
    :   ^(FILEFORMAT doc
            {
                class_->def("extensions", std::vector<std::string>());
            }
            (n=CONSTANTNAME
                {
                    class_->attr<std::vector<std::string> >("extensions").push_back(get_string($n.text));
                }
            )*
        )
    ;

declarations[PClass class_]
    :   (fielddefine | classdefine[class_] | enumdefine)+
    ;

enumdefine
    :   ^(ENUMDEF doc TYPENAME TYPENAME enumconstant+);

enumconstant
    :   ^(ENUMCONSTDEF doc CONSTANTNAME expression);

classdefine[PClass class_]
@init {
    PClass new_class;
    PClass base_class;
}
    :   ^(CLASSDEF doc name=TYPENAME 
            ^(BASE 
                (base=TYPENAME
                    {
                        base_class = class_->attr<PClass>(get_string($base.text));
                    }
                )?
            )
            {
                if (base_class) {
                    new_class = class_->class_(
                        get_string($name.text),
                        base_class);
                } else {
                    new_class = class_->class_(
                        get_string($name.text));
                };
            }
            declarations[new_class]?
        )
    ;

/* empty OP_INDEX generated by XML.g, so we handle it here */
fielddefine
    :   ^(FIELDDEF doc TYPENAME VARIABLENAME (OP_INDEX|fieldindices)? fieldarguments? ABSTRACT?)
    |   ^(IF expression fielddefines
            (^(ELIF expression fielddefines))*
            (^(ELSE fielddefines))?
        )
    ;

// for convenience in the above parser rule
fielddefines
    :   fielddefine+
    ;

kwarg
    :   ^(KWARG VARIABLENAME expression)
    ;

fieldarguments
    :   ^(OP_CALL kwarg+)
    ;

fieldindices
    :   ^(OP_INDEX expression+)
    ;

expression
    :   VARIABLENAME
    |   INT
    |   FLOAT
    |   STRING
    |   ^(OP_LOGICAL_OR expression expression)
    |   ^(OP_LOGICAL_AND expression expression)
    |   ^(OP_LOGICAL_NOT expression)
    |   ^(OP_EQ expression expression)
    |   ^(OP_NEQ expression expression)
    |   ^(OP_GT expression expression)
    |   ^(OP_LT expression expression)
    |   ^(OP_GTEQ expression expression)
    |   ^(OP_LTEQ expression expression)
    |   ^(OP_BITWISE_OR expression expression)
    |   ^(OP_BITWISE_AND expression expression)
    |   ^(OP_LEFTSHIFT expression expression)
    |   ^(OP_RIGHTSHIFT expression expression)
    |   ^(OP_PLUS expression expression)
    |   ^(OP_MINUS expression expression)
    |   ^(OP_NEGATE expression)
    |   ^(OP_BITWISE_NOT expression)
    |   ^(OP_MULTIPLY expression expression)
    |   ^(OP_DIVIDE expression expression)
    |   ^(OP_MODULO expression expression)
    |   ^(OP_POWER expression expression)
    |   ^(OP_CALL expression kwarg+)
    |   ^(OP_INDEX expression expression+)
    ;
