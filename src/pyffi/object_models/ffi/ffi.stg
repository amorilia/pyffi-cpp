group ffi;

templatehelper(arg) ::= "<arg>"

ffi(head, decls) ::= <<
<head>

<decls>
>>

formatdefine(doc, names) ::= <<
<doc>
fileformat <names; separator=", ">

>>

enumdefine(doc, name, type, constants) ::= <<
<doc>
enum <name>(<type>):
    <constants>

>>

enumconstant(doc, name, value) ::= <<
<doc>
<name> = <value>

>>

classdefine(doc, type, decls, fields) ::= <<
<doc>
class <type>:
    <decls>
    <fields>

>>

typeblock(types) ::= <<
type:
    <types>

>>

typedefine(doc, type) ::= <<
<doc>
<type>

>>

fielddefine(doc, type, name) ::= <<
<doc>
<type> <name>

>>

parameterblock(parameters) ::= <<
parameter:
    <parameters>

>>

parameterdefine(doc, type, name, kwargs) ::= <<
<doc>
<type> <name><if(kwargs)><kwargs><endif>

>>

ifelifelse(ifexp, ifdefs, elifexp, elifdefs, elsedefs) ::= <<
if <ifexp>:
    <ifdefs><if(elifexp)><elifexp,elifdefs:{exp, defs|
elif <exp>:
    <defs>
}><endif><if(elsedefs)>else:
    <elsedefs><endif>
>>

docstring(str) ::= <<
# <str>
>>

doc(docstrings) ::= <<
<docstrings:docstring()>
>>

kwarg(name, exp) ::= <<
<name>=<exp>
>>

fieldparameters(kwargs) ::= <<
(<kwargs; separator=", ">)
>>

op_logical_or(e1, e2) ::= "(<e1> or <e2>)"
op_logical_and(e1, e2) ::= "(<e1> and <e2>)"
op_logical_not(e1) ::= "(not <e1>)"
op_eq(e1, e2) ::= "(<e1> == <e2>)"
op_neq(e1, e2) ::= "(<e1> != <e2>)"
op_gt(e1, e2) ::= "(<e1> \> <e2>)"
op_lt(e1, e2) ::= "(<e1> \< <e2>)"
op_gteq(e1, e2) ::= "(<e1> \>= <e2>)"
op_lteq(e1, e2) ::= "(<e1> \<= <e2>)"
op_bitwise_or(e1, e2) ::= "(<e1> | <e2>)"
op_bitwise_and(e1, e2) ::= "(<e1> & <e2>)"
op_leftshift(e1, e2) ::= "(<e1> \<\< <e2>)"
op_rightshift(e1, e2) ::= "(<e1> \>\> <e2>)"
op_plus(e1, e2) ::= "(<e1> + <e2>)"
op_minus(e1, e2) ::= "(<e1> - <e2>)"
op_negate(e1) ::= "(-<e1>)"
op_bitwise_not(e1) ::= "(~<e1>)"
op_multiply(e1, e2) ::= "(<e1> * <e2>)"
op_divide(e1, e2) ::= "(<e1> / <e2>)"
op_modulo(e1, e2) ::= "(<e1> % <e2>)"
op_power(e1, e2) ::= "(<e1> ** <e2>)"

string(text) ::= "\"<text>\""
